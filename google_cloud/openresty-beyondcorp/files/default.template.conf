error_log /dev/stderr debug;
proxy_cache_path /tmp/cache keys_zone=tokens:10m;

server {
    listen       8080;
    server_name  localhost;
    # Google Public DNS is simplest to configure
    resolver 8.8.8.8; 

    location /login {
        default_type "text/html";
        root /assets;
    }

    # Example of public access by fetching a token automatically
    location /anonymous { 
         # Anonymous access
         access_by_lua_block {
             local upstreamtoken = ngx.location.capture('/token').body
             ngx.req.set_header("Authorization", "Bearer " .. upstreamtoken)
         }

         proxy_set_header X-Real-IP $remote_addr;
         proxy_pass ${UPSTREAM_URL};
    }

    # Proxy all request upstream. Redirect to Google Signin and only allow
    # users from AUTHORIZED_DOMAIN in.
    location / {
        # Caller should provide a cookie ACCESSTOKEN or Bearer token containing an identity_token
        # If its valid, we exchange for the server's identity_token and proxy
        # to upstream
        rewrite_by_lua_block {
            -- Check ACCESSTOKEN cookie present
            local access_token = ngx.var.cookie_ACCESSTOKEN
            -- Fallback to Bearer token
            if access_token == nil then
                local auth_header = ngx.req.get_headers()["Authorization"]
                if auth_header ~= nil then
                    _, _, access_token = auth_header:find("Bearer%s+(.+)")
                end
            end

            -- If no access_token found, redirect to login
            if access_token == nil then
                ngx.log(ngx.WARN, "No TOKEN present") 
                return ngx.redirect("/login?returnurl=" .. ngx.var.request_uri, 302)
            end
            
            -- Verify ACCESSTOKEN token and obtain a server identity token
            local verification, upstreamtoken = ngx.location.capture_multi {
                { '/tokeninfo', { args = { access_token = access_token}}},
                { '/token'}
            }
            
            -- Check token verified ok
            if verification.status ~= 200 then
                ngx.status = 401  
                ngx.say("Invalid token")  
                return ngx.exit(401) 
            end
        
            -- Decode Googles tokeinfo response
            local cjson = require "cjson"
            local tokeninfo = cjson.decode(verification.body)

            -- Check audience is our Oauth client, not some random one
            if tokeninfo.aud ~= "${OAUTH_CLIENT_ID}" then
                ngx.log(ngx.WARN, "Invalid aud: " .. tokeninfo.aud) 
                return ngx.redirect("/login?returnurl=" .. ngx.var.request_uri, 302)
            end

            -- Check the user has a verified email is in the domain we want to allow
            -- And that their email address ends in @<AUTHERIZED_DOMAIN>
            local ending = "@" .. "${AUTHORIZED_DOMAIN}"
            if tokeninfo.email_verified ~= "true" or
               not tokeninfo.email:find(ending, -ending:len()) then
                ngx.log(ngx.WARN, "Not a domain user")
                return ngx.redirect("/login?returnurl=" .. ngx.var.request_uri, 302)
            end

            -- Indicate this request is autherized for upstream
            ngx.req.set_header("Authorization", "Bearer " .. upstreamtoken.body)
        }
        proxy_set_header X-Real-IP $remote_addr;
        proxy_pass ${UPSTREAM_URL};
    }

    location /token {
        internal; # Security! don't expose to outside world!
        # Avoid requesting a token every inbound request through caching
        proxy_cache tokens;
        proxy_cache_valid 200 5m; # 5 min cache of token
        proxy_set_header Metadata-Flavor "Google";
        proxy_pass http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/identity?audience=${UPSTREAM_URL};
    }

    location /accesstoken {
        internal; # Security! don't expose to outside world!
        # Avoid requesting a token every inbound request through caching
        proxy_cache tokens;
        proxy_cache_valid 200 5m; # 5 min cache of token
        proxy_set_header Metadata-Flavor "Google";
        proxy_pass http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/token;
    }

    location /tokeninfo {
        internal; # No need to expose
        # Avoid requesting a tokeninfo every inbound request through caching
        proxy_cache tokens;
        proxy_cache_valid 200 1m; 

        # Ideally we would proxy to the oauth2 address but it breaks for an unknown reason
        # Something to do with SSL ??? 
        # proxy_pass https://oauth2.googleapis.com/tokeninfo;

        # So this is our workaround, we do an internal http redirect instead
        proxy_pass http://127.0.0.1:8080/httptokeninfo;
    }

    location /httptokeninfo {
        # internal; # Would be better not to expose but its 'ok', its a public endpoint anyway
        content_by_lua_block {
            local http = require "resty.http"
            local httpc = http.new()
            local res, err = httpc:request_uri(
                "https://oauth2.googleapis.com/tokeninfo?access_token=" .. ngx.var.arg_access_token,
                { ssl_verify = false }
            )
            if not res then
                ngx.status = 500
                ngx.say("failed to request: ", err)
                return
            end
            ngx.status = res.status
            ngx.say(res.body)
        }
    }

    error_page   500 502 503 504  /50x.html;
    location = /50x.html {
        root   /usr/local/openresty/nginx/html;
    }
    
    location /zapier/ {
        # This is Camunda specific functionality
        # Rewrite the incoming payload to suit Camunda REST api
        access_by_lua_block {
            if ngx.req.get_method() == "POST" then
                local cjson = require "cjson"

                ngx.req.read_body()
                local old_body = ngx.req.get_body_data()
                ngx.log(ngx.WARN, "old_body: " .. old_body)
                local body = cjson.decode(old_body)

                -- Zapier cannot express variable: {key1: {type: String, value: blah}}
                -- So we let it jsut do variable: {key1: blah}} and assume strings only
                for key, value in pairs(body) do
                    if key == "variables" or key == "processVariables" or key == "correlationKeys" then
                        for inner_key, inner_value in pairs(value) do
                            value[inner_key] = {
                                type = "String",
                                value = inner_value
                            }
                        end
                    end
                end

                local new_body = cjson.encode(body)
                ngx.log(ngx.WARN, "new_body: " .. new_body)
                ngx.req.set_body_data(new_body)
                ngx.req.set_body_data(new_body)
            end
        }
        proxy_pass_request_headers on;
        proxy_pass ${UPSTREAM_URL};
    }

    location /slack/command/ {
        # https://api.slack.com/interactivity/slash-commands#app_command_handling
        access_by_lua_block {
            if ngx.req.get_method() == "POST" then
                local cjson = require "cjson"

                ngx.req.read_body()
                ngx.log(ngx.WARN, "load reqargs")
                local get, post, files = require "resty.reqargs"()

                -- Create a signal request to camunda

                ngx.log(ngx.WARN, "Create signal body")
                local signal = {
                    name = "slackCommand",
                    variables = {}
                }

                ngx.log(ngx.WARN, "Fill variables")
                for key, value in pairs(post) do
                    signal.variables[key] = {
                        type = "String",
                        value = value
                    }
                end

                ngx.log(ngx.WARN, "Encode signal")
                local new_body = cjson.encode(signal)
                ngx.log(ngx.WARN, "new_body: " .. new_body)

                ngx.log(ngx.WARN, "Set body")
                ngx.req.set_body_data(new_body)

                -- TODO: do this elsewhere
                ngx.log(ngx.WARN, "Fetch token")
                local upstreamtoken = ngx.location.capture('/token')
                ngx.req.set_header("Authorization", "Bearer " .. upstreamtoken.body)
            end
        }
        
        proxy_set_header Content-Type application/json;
        proxy_pass_request_headers on;
        # proxy_pass ${UPSTREAM_URL}/engine-rest/signal; 
        proxy_pass https://127.0.0.1:8080/wal/engine-rest/signal;
    }

    # The WAL takes a request, places in an envelope and publishes it to pubusb
    location /wal/ {
        # internal;
        content_by_lua_block {

            ngx.log(ngx.WARN, "Wal")

            local cjson = require "cjson"
            local b64 = require("ngx.base64")
            local upstreamtoken = cjson.decode(ngx.location.capture('/accesstoken').body).access_token
            ngx.req.read_body()
            local body = ngx.req.get_body_data() -- Might be nil
            
            local headers = ngx.req.get_headers()

            local envelope = {
                messages = {
                    [1] = {
                        data = b64.encode_base64url(body),
                        attributes = {
                            headers = cjson.encode(headers),
                            method = ngx.req.get_method(),
                            uri = ngx.var.request_uri
                        }
                    }
                }
            }
            
            local http = require "resty.http"
            local httpc = http.new()
            local pubsub_publish = "https://pubsub.googleapis.com/v1/${WAL_TOPIC}:publish"
            ngx.log(ngx.WARN, "Request " .. pubsub_publish)
            ngx.log(ngx.WARN, "Token " .. upstreamtoken)
            local res, err = httpc:request_uri(
                pubsub_publish,
                {
                    method = "POST",
                    body = cjson.encode(envelope),
                    headers = {
                        ["Content-Type"] = "application/json",
                        ["Authorization"] = "Bearer " .. upstreamtoken
                    },
                    ssl_verify = false
                }
            )
            if not res then
                ngx.status = 500
                ngx.say("failed to request: ", err)
                return
            end
            ngx.status = res.status
            ngx.say(res.body)
        }
    }
}
