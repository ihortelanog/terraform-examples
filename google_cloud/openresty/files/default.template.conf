error_log /dev/stderr debug;
proxy_cache_path /tmp/cache keys_zone=tokens:10m;

server {
    listen       8080;
    server_name  localhost;

    location /login {
        default_type "text/html";
        root /assets;
    }

    # matches camunda-welcome, camunda-invoice etc. too
    location /camunda { 
        # Anonymous access
        access_by_lua_block {
            local upstreamtoken = ngx.location.capture('/token').body
            ngx.req.set_header("Authorization", "Bearer " .. upstreamtoken)
        }

        proxy_set_header X-Real-IP $remote_addr;
        proxy_pass ${UPSTREAM_URL};
    }

    location /engine-rest {
        # Verify token in cookie or redirect to login
        rewrite_by_lua_block {
            ngx.log(ngx.WARN, "Check cookie") 
            if ngx.var.cookie_IDTOKEN == nil then
                ngx.log(ngx.WARN, "No cookie") 
                return ngx.redirect("/login?returnurl=" .. ngx.var.request_uri, 302)
            end
            ngx.log(ngx.WARN, "Check token")

            local verification, upstreamtoken = ngx.location.capture_multi {
                { '/httptokeninfo', { args = { id_token = ngx.var.cookie_IDTOKEN}}},
                { '/token'}
            }
            
            if verification.status ~= 200 then
                ngx.log(ngx.WARN, "Invalid status: " .. verification.status) 
                return ngx.redirect("/login?returnurl=" .. ngx.var.request_uri, 302)
            end
        
            ngx.log(ngx.WARN, "Token: " .. verification.body)
            local cjson = require "cjson"
            local tokeninfo = cjson.decode(verification.body)
            ngx.log(ngx.WARN, "Decoded  OK") 
            if tokeninfo.aud ~= "${OAUTH_CLIENT_ID}" then
                ngx.log(ngx.WARN, "Invalid aud in: " .. tokeninfo) 
                return ngx.redirect("/login?returnurl=" .. ngx.var.request_uri, 302)
            end

            ngx.req.set_header("Authorization", "Bearer " .. upstreamtoken.body)
        }

        proxy_buffering off;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_pass ${UPSTREAM_URL};
    }

    location /token {
        internal; # Security! don't expose to outside world!
        # Improve performance with caching outbound results
        proxy_cache tokens;
        proxy_cache_valid 200 5m; # 5 min cache of token
        proxy_buffering on;
        proxy_set_header Metadata-Flavor "Google";
        proxy_pass http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/identity?audience=${UPSTREAM_URL};
    }

    location /tokeninfo {
        # internal; # No need to expose
        # Improve performance with caching outbound results
        proxy_cache tokens;
        proxy_cache_valid 200 1m; 
        proxy_buffering on;
        proxy_set_header content-type "application/json";
        # proxy_pass https://oauth2.googleapis.com/tokeninfo;
        proxy_pass http://127.0.0.1/httptokeninfo:8080;
    }

    location /httptokeninfo {
        resolver 8.8.8.8;  # use Google's open DNS server for an example

        #!!! TODO unable to get local issuer certificate open resty
        content_by_lua_block {
            ngx.log(ngx.WARN, "Token to tokeninfo " .. ngx.var.arg_id_token) 
            local http = require "resty.http"
            local httpc = http.new()
            local res, err = httpc:request_uri(
                "https://oauth2.googleapis.com/tokeninfo?id_token=" .. ngx.var.arg_id_token,
                { ssl_verify = false })

            if not res then
                ngx.say("failed to request: ", err)
                return
            end
            ngx.status = res.status
            ngx.say(res.body)
        }
    }

    #error_page  404              /404.html;
    # redirect server error pages to the static page /50x.html
    #
    error_page   500 502 503 504  /50x.html;
    location = /50x.html {
        root   /usr/local/openresty/nginx/html;
    }
}
